#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда

#Область ПрограммныйИнтерфейс

Процедура ЗаписатьКалькуляциюРасходов(ПараметрыКалькуляции) Экспорт
	
	Расходы = ПолучитьИзВременногоХранилища(ПараметрыКалькуляции.АдресРасходов);
	
	НаборЗаписей = РегистрыСведений.КалькуляцияРасходовВСчетеНаОплатуПокупателю.СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.СчетНаОплатуПокупателю.Установить(ПараметрыКалькуляции.СчетНаОплатуПокупателю);
	НаборЗаписей.Отбор.Организация.Установить(ПараметрыКалькуляции.Организация);
	
	Для Каждого СтрокаРасходы Из Расходы Цикл
		НоваяСтрока = НаборЗаписей.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаРасходы);
		НоваяСтрока.СчетНаОплатуПокупателю = ПараметрыКалькуляции.СчетНаОплатуПокупателю;
		НоваяСтрока.Организация            = ПараметрыКалькуляции.Организация;
	КонецЦикла;
	
	НаборЗаписей.Записать();
	
КонецПроцедуры

Процедура УдалитьНесвязанныеЭлементыКалькуляцииРасходов(ПараметрыКалькуляции) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("СчетНаОплатуПокупателю",  ПараметрыКалькуляции.СчетНаОплатуПокупателю);
	Запрос.УстановитьПараметр("КлючКалькуляцииРасходов", ПараметрыКалькуляции.КлючиКалькуляцииРасходов);
	
	ТекстЗапроса =
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	КалькуляцияРасходовВСчетеНаОплатуПокупателю.КлючКалькуляцииРасходов КАК КлючКалькуляцииРасходов
		|ИЗ
		|	РегистрСведений.КалькуляцияРасходовВСчетеНаОплатуПокупателю КАК КалькуляцияРасходовВСчетеНаОплатуПокупателю
		|ГДЕ
		|	КалькуляцияРасходовВСчетеНаОплатуПокупателю.СчетНаОплатуПокупателю = &СчетНаОплатуПокупателю
		|	И НЕ КалькуляцияРасходовВСчетеНаОплатуПокупателю.КлючКалькуляцииРасходов В (&КлючКалькуляцииРасходов)";
	
	Запрос.Текст = ТекстЗапроса;
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат;
	КонецЕсли;
	
	Выборка = РезультатЗапроса.Выбрать();
	Пока Выборка.Следующий() Цикл
		
		НаборЗаписей = РегистрыСведений.КалькуляцияРасходовВСчетеНаОплатуПокупателю.СоздатьНаборЗаписей();
		НаборЗаписей.Отбор.СчетНаОплатуПокупателю.Установить(ПараметрыКалькуляции.СчетНаОплатуПокупателю);
		НаборЗаписей.Отбор.КлючКалькуляцииРасходов.Установить(Выборка.КлючКалькуляцииРасходов);
		НаборЗаписей.Записать();
		
	КонецЦикла;
	
КонецПроцедуры

Функция ПолучитьКомпонентыСоставаПродукции(Спецификация) Экспорт
	
	КомпонентыСоставаПродукции = Новый ТаблицаЗначений;
	КомпонентыСоставаПродукции.Колонки.Добавить("Номенклатура",        Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
	КомпонентыСоставаПродукции.Колонки.Добавить("Количество",          ОбщегоНазначения.ОписаниеТипаЧисло(15, 3, ДопустимыйЗнак.Неотрицательный));
	КомпонентыСоставаПродукции.Колонки.Добавить("КоличествоНаЕдиницу", ОбщегоНазначения.ОписаниеТипаЧисло(15, 3, ДопустимыйЗнак.Неотрицательный));
	
	КомпонентыСоставаПродукции(КомпонентыСоставаПродукции, Спецификация);
	Возврат КомпонентыСоставаПродукции;
	
КонецФункции

// СтандартныеПодсистемы.УправлениеДоступом

// См. УправлениеДоступомПереопределяемый.ПриЗаполненииСписковСОграничениемДоступа.
Процедура ПриЗаполненииОграниченияДоступа(Ограничение) Экспорт

	Ограничение.Текст =
	"РазрешитьЧтениеИзменение
	|ГДЕ
	|	ЗначениеРазрешено(Организация)";
	
КонецПроцедуры

// Конец СтандартныеПодсистемы.УправлениеДоступом

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция КомпонентыСоставаПродукции(КомпонентыСоставаПродукции, Спецификация)
	
	СоставОсновнойСпецификации = СоставОсновнойСпецификацииНаЕдиницуНормы(Спецификация);
	
	// Заполним КомпонентыСоставаПродукции строками из СоставОсновнойСпецификации,
	// Если у элемента текущей строки СоставаОсновнойСпецификации есть своя спецификация, то сделаем разузлование
	// Запишем разузлование в конец СоставОсновнойСпецификации,
	// и текущий элемент в КомпонентыСоставаПродукции записывать не будем.
	// Записываем в КомпонентыСоставаПродукции только те элементы, у которых нет спецификации.
	// В итоге в КомпонентыСоставаПродукции будут только те компоненты, которые требуются для производства продукции
	// 
	// Если один из элементов КомпонентыСоставаПродукции содержит в своей спецификации сам себя,
	// то СоставОсновнойСпецификации будет заполняться бесконечно.
	// Выводим не больше строк, чем указано в функции МаксимальноеКоличествоСтрокСпецификации.
	// Если строк больше чем МаксимальноеКоличествоСтрокСпецификации, то это значит
	// 1) один из элементов КомпонентыСоставаПродукции содержит в своей спецификации сам себя,
	// 2) слишком большое количество строк для перестает быть информативным.
	//
	// Поэтому остановим алгоритм разузлования и выведем пользователю СоставОсновнойСпецификации продукции.
	КоличествоСтрокВСпецификации = 1;
	
	Для Каждого СтрокаСпецификации Из СоставОсновнойСпецификации Цикл
		
		Если КоличествоСтрокВСпецификации > МасимальноеКоличествоСтрокСпецификации() Тогда
			КомпонентыСоставаПродукции.Очистить();
			ЗаполнитьКомпонентыСоставаПродукцииОсновнойСпецификациейБезРазузлования(КомпонентыСоставаПродукции, Спецификация);
			Возврат КомпонентыСоставаПродукции;
		КонецЕсли;
		
		// Продукция производится из полуфабрикатов,
		// если у полуфобрикатов есть свои полуфабрикаты, то произведем разузлование
		СпецификацияПолуфабриката = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(СтрокаСпецификации.Номенклатура, "ОсновнаяСпецификацияНоменклатуры");
		СоставОсновнойСпецификацииПолуфабриката = СоставОсновнойСпецификацииНаЕдиницуНормы(СпецификацияПолуфабриката);
		
		Если ЗначениеЗаполнено(СоставОсновнойСпецификацииПолуфабриката) Тогда
			
			// Запишем разузлование в конец СоставОсновнойСпецификации исходной продукции
			Для Каждого СтрокаСпецификацииПолуфабриката Из СоставОсновнойСпецификацииПолуфабриката Цикл
				ДополнительнаяСтрокаСпецификации              = СоставОсновнойСпецификации.Добавить();
				ДополнительнаяСтрокаСпецификации.Номенклатура = СтрокаСпецификацииПолуфабриката.Номенклатура;
				ДополнительнаяСтрокаСпецификации.Количество   = СтрокаСпецификацииПолуфабриката.Количество * СтрокаСпецификации.Количество;
			КонецЦикла;
		Иначе
			СтрокаКомпонент = КомпонентыСоставаПродукции.Добавить();
			СтрокаКомпонент.Номенклатура                      = СтрокаСпецификации.Номенклатура;
			СтрокаКомпонент.Количество                        = СтрокаСпецификации.Количество;
		КонецЕсли;
		
		КоличествоСтрокВСпецификации = КоличествоСтрокВСпецификации + 1;
		
	КонецЦикла;
	
	Возврат КомпонентыСоставаПродукции;
	
КонецФункции

Функция СоставОсновнойСпецификацииНаЕдиницуНормы(Спецификация)
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", Спецификация);
	
	Запрос.Текст =
	"ВЫБРАТЬ
	|	СпецификацииНоменклатурыИсходныеКомплектующие.Номенклатура КАК Номенклатура,
	|	СпецификацииНоменклатурыИсходныеКомплектующие.Количество КАК Количество,
	|	СпецификацииНоменклатурыИсходныеКомплектующие.Ссылка.Количество КАК КоличествоПродукции
	|ИЗ
	|	Справочник.СпецификацииНоменклатуры.ИсходныеКомплектующие КАК СпецификацииНоменклатурыИсходныеКомплектующие
	|ГДЕ
	|	СпецификацииНоменклатурыИсходныеКомплектующие.Ссылка = &Ссылка";
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	СоставОсновнойСпецификации = Новый ТаблицаЗначений;
	СоставОсновнойСпецификации.Колонки.Добавить("Номенклатура", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
	СоставОсновнойСпецификации.Колонки.Добавить("Количество",   ОбщегоНазначения.ОписаниеТипаЧисло(15, 3, ДопустимыйЗнак.Неотрицательный));
	
	Пока Выборка.Следующий() Цикл
		
		СтрокаСпецификации = СоставОсновнойспецификации.Добавить();
		СтрокаСпецификации.Номенклатура = Выборка.Номенклатура;
		СтрокаСпецификации.Количество   = Выборка.Количество/Выборка.КоличествоПродукции;
		
	КонецЦикла;
	
	Возврат СоставОсновнойСпецификации;
	
КонецФункции

Функция МасимальноеКоличествоСтрокСпецификации()
	
	// Пользователю нужен список компонент основной спецификации.
	// Если в списке более 1000 строк, тогда список перестает быть информативным.
	// Есть два сценари:
	// 1) разузлование может зациклится, значит будет бесконечное число итераций,
	// такой цикл останавливаем, выведем этот список без разузлования.
	// 2) цикл имеет очень большой список СоставОсновнойСпецификации (количество строк больше МасимальноеКоличествоСтрокСпецификации),
	// тогда просто выведем этот список без разузлования, так как разузлование только увеличит количество строк.
	МасимальноеКоличествоСтрокСпецификации = 1000;
	Возврат МасимальноеКоличествоСтрокСпецификации;
	
КонецФункции

Процедура ЗаполнитьКомпонентыСоставаПродукцииОсновнойСпецификациейБезРазузлования(КомпонентыСоставаПродукции, Продукция)
	
	СоставОсновнойСпецификации = СоставОсновнойСпецификацииНаЕдиницуНормы(Продукция);
	
	Для Каждого СтрокаСпецификации Из СоставОсновнойСпецификации Цикл
		СтрокаКомпонент = КомпонентыСоставаПродукции.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаКомпонент, СтрокаСпецификации);
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#КонецЕсли
