#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда

#Область ПрограммныйИнтерфейс

// Считывает данные файла в табличный документ и определяет загружаемые колонки.
//
// Параметры:
//   ПараметрыЗадания - Структура - структура с ключами:
//      * ХранилищеДанныхФайла - ХранилищеЗначения - двоичные данные файла, упакованные в хранилище значений.
//      * РасширениеФайла - Строка - расширение файла.
//      * ОписаниеКолонок - ТаблицаЗначений - описание загружаемых колонок, см. НовыйОписаниеЗагружаемыхКолонок().
//   АдресРезультата - УникальныйИдентификатор - адрес во временном хранилище для сохранения результатов.
//
Процедура ОбработатьДанныеИзФайла(ПараметрыЗадания, АдресРезультата) Экспорт
	
	ПараметрыЗадания.Вставить("МакетЗаголовка", ПолучитьМакет("МакетЗаголовка"));
	
	ТабличныйДокумент = ЗагрузкаДанныхИзВнешнихФайлов.ЗагрузитьФайлВТабличныйДокумент(ПараметрыЗадания);
	
	КоличествоСтрокЗаголовка = 1; // Отводится на строку элементов управления.
	
	// Прибавляем 1, т.к. в параметрах передан индекс строки, а не ее номер.
	НачалоСтрокРеестра     = КоличествоСтрокЗаголовка + ПараметрыЗадания.НачалоСтрокРеестра + 1;
	ОкончаниеСтрокРеестра  = КоличествоСтрокЗаголовка + ПараметрыЗадания.ОкончаниеСтрокРеестра + 1;
	
	НачалоСтрокШапки       = КоличествоСтрокЗаголовка + 1; // Начинается после строки элементов управления.
	ОкончаниеСтрокШапки    = НачалоСтрокРеестра - 1;       // Заканчивается перед строкой таблицы реестра.
	КоличествоСтрокШапки   = ОкончаниеСтрокШапки - НачалоСтрокШапки + 1;
	
	НачалоСтрокПодвала     = ОкончаниеСтрокРеестра + 1;
	ОкончаниеСтрокПодвала  = ТабличныйДокумент.ВысотаТаблицы;
	КоличествоСтрокПодвала = ОкончаниеСтрокПодвала - НачалоСтрокПодвала + 1;
	
	Если КоличествоСтрокПодвала > 0 Тогда
		СтрокиПодвала = ТабличныйДокумент.Область("R" + НачалоСтрокПодвала + ":" + "R" + ОкончаниеСтрокПодвала);
		ТабличныйДокумент.УдалитьОбласть(СтрокиПодвала, ТипСмещенияТабличногоДокумента.ПоВертикали);
		// Из-за подвала некоторые пустые колонки могли быть не удалены.
		ЗагрузкаДанныхИзВнешнихФайлов.УдалитьПустыеКолонки(ТабличныйДокумент, 2);
	КонецЕсли;
	
	Если КоличествоСтрокШапки > 0 Тогда
		СтрокиШапки = ТабличныйДокумент.Область("R" + НачалоСтрокШапки + ":" + "R" + ОкончаниеСтрокШапки);
		ТабличныйДокумент.УдалитьОбласть(СтрокиШапки, ТипСмещенияТабличногоДокумента.ПоВертикали);
		// Из-за шапки некоторые пустые колонки могли быть не удалены.
		ЗагрузкаДанныхИзВнешнихФайлов.УдалитьПустыеКолонки(ТабличныйДокумент, 2);
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("ДанныеФайла", Новый ХранилищеЗначения(ТабличныйДокумент));
	
	ПоместитьВоВременноеХранилище(Результат, АдресРезультата);
	
КонецПроцедуры

// По данным табличного документа заполняет таблицу для загрузки.
//
// Параметры:
//   ПараметрыЗадания - Структура - структура с ключами:
//      * ХранилищеДанных - ХранилищеЗначения - табличный документ, содержащий данные.
//   АдресРезультата - УникальныйИдентификатор - адрес во временном хранилище для сохранения результатов.
//
Процедура ПолучитьТаблицуДанныхДляЗагрузки(ПараметрыЗадания, АдресРезультата) Экспорт
	ДопНастройки = Новый Структура;
	Для каждого КлючИЗначение Из ПараметрыЗадания Цикл
		Если КлючИЗначение.Ключ <> "ДвоичныеДанные" Тогда
			ДопНастройки.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		КонецЕсли;
	КонецЦикла;
	
	ДанныеЗаполнения = ДанныеРеестра(ПараметрыЗадания.ДвоичныеДанные, ДопНастройки);
	
	ПоместитьВоВременноеХранилище(ДанныеЗаполнения, АдресРезультата);
КонецПроцедуры

// Процедура - Сохраняет пользовательское соответствие имен колонок и загружаемых данных.
//
// Параметры:
//  СоответствиеИменКолонок	 - Структура - Соответствие загружаемых данных и пользовательского представления колонок.
//                                         См. ЗагрузкаДанныхИзВнешнихФайлов.СоответствиеИменКолонокЗагружаемымДанным()
//
Процедура СохранитьСоответствиеИменКолонокЗагружаемымДанным(БанковскийСчет, СоответствиеИменКолонок) Экспорт
	
	КлючОбъекта = БанковскийСчет.УникальныйИдентификатор();
	ОбщегоНазначения.ХранилищеОбщихНастроекСохранить(
		КлючОбъекта, "СохраненноеСоответствиеПользовательскихКолонок", СоответствиеИменКолонок);
	
КонецПроцедуры

Функция СохраненноеСоответствиеИменКолонокЗагружаемымДанным(БанковскийСчет) Экспорт
	
	КлючОбъекта = БанковскийСчет.УникальныйИдентификатор();
	Возврат ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить(
		КлючОбъекта, "СохраненноеСоответствиеПользовательскихКолонок", Новый Соответствие);
	
КонецФункции

Функция ДанныеРеестра(ДвоичныеДанные, ДопНастройки) Экспорт
	РеестрПострочно = ДанныеРеестраПрочитать(ДвоичныеДанные);
	ДанныеРеестра   = ДанныеРеестраРазобрать(РеестрПострочно, ДопНастройки);
	
	Возврат ДанныеРеестра;
КонецФункции

// Возврашает таблицу дополнительных реквизитов для банковского счета
// Эти реквизиты используются для выставления счета на оплату
//
// Параметры:
//  <БанковскийСчет>  - <СправочникСсылка.БанковскиеСчета> - банковский счет
//                 по которому получаем реквизиты
// Возвращаемое значение:
//   <ТаблицаЗначений>  
//     - Ссылка - СправочникСсылка.РеквизитыКодаДляОплаты
//     - Код - идентификатор дополнительного реквизита для QR кода и реестра
//
Функция ДополнительныеРеквизитыРеестра(БанковскийСчет) Экспорт
	Запрос = Новый Запрос;
	
	Запрос.УстановитьПараметр("БанковскийСчет", БанковскийСчет);
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	РеквизитыКодаДляОплаты.Ссылка КАК Ссылка,
	|	РеквизитыКодаДляОплаты.Код КАК Код
	|ИЗ
	|	Справочник.РеквизитыКодаДляОплаты КАК РеквизитыКодаДляОплаты
	|ГДЕ
	|	РеквизитыКодаДляОплаты.Владелец = &БанковскийСчет
	|	И НЕ РеквизитыКодаДляОплаты.ПометкаУдаления";
	
	Возврат Запрос.Выполнить().Выгрузить();
КонецФункции


#КонецОбласти

#Область СлужебныеПроцедурыФункции

Функция ДанныеРеестраПрочитать(ДвоичныеДанные)
	Перем Разделитель;
	
	Результат = НовыйСтруктураРеестра();
	
	ЧтениеДанных = Новый ЧтениеДанных(ДвоичныеДанные);
	ЧтениеТекста = Новый ЧтениеТекста(ЧтениеДанных.ИсходныйПоток());
	
	КоличествоКолонокВПервойСтрокеМеньше = Ложь;
	КоличествоКолонокВПервойСтроке  = 0;
	КоличествоКолонокВоВторойСтроке = 0;
	
	ЭтоПодвал = Ложь;
	ИндексСтроки = -1;
	Пока Истина Цикл
		СтрокаТекста = СокрЛП(ЧтениеТекста.ПрочитатьСтроку());
		ИндексСтроки = ИндексСтроки + 1;
		Если Не ЗначениеЗаполнено(СтрокаТекста) Тогда
			СледующаяСтрокаТекста = СокрЛП(ЧтениеТекста.ПрочитатьСтроку());
			Если ЗначениеЗаполнено(СледующаяСтрокаТекста) Тогда
				СтрокаТекста = СледующаяСтрокаТекста;
			Иначе
				Прервать;
			КонецЕсли;
		КонецЕсли;
		
		Если ЭтоШапка(СтрокаТекста) Тогда
			Результат.Заголовок.Добавить(СтрокаТекста);
			Продолжить;
		КонецЕсли;
		
		Если ЭтоПодвал(СтрокаТекста) Или ЭтоПодвал Тогда
			ЭтоПодвал = Истина;
			Результат.Подвал.Добавить(СтрокаТекста);
			Продолжить;
		КонецЕсли;
		
		Если ИндексСтроки = 0 Тогда
			Если Разделитель = Неопределено Тогда
				Разделитель = ВыделитьРазделитель(СтрокаТекста);
			КонецЕсли;
			
			ДанныеСтроки = СтрРазделить(СтрокаТекста, Разделитель, Истина);
			КоличествоКолонокВПервойСтроке  = ДанныеСтроки.Количество();
		ИначеЕсли ИндексСтроки = 1 Тогда
			ДанныеСтроки = СтрРазделить(СтрокаТекста, Разделитель, Истина);
			КоличествоКолонокВоВторойСтроке = ДанныеСтроки.Количество();
			КоличествоКолонокВПервойСтрокеМеньше = КоличествоКолонокВПервойСтроке > 1
				И КоличествоКолонокВПервойСтроке < КоличествоКолонокВоВторойСтроке;
		КонецЕсли;
		
		УстановитьНачалоСтрокиРеестра(Результат, ИндексСтроки, КоличествоКолонокВПервойСтрокеМеньше);
		УстановитьОкончаниеСтрокРеестра(Результат, ИндексСтроки);
		
		Если КоличествоКолонокВПервойСтрокеМеньше Тогда
			// В большинстве реестров "с заголовком", данные заголовка разбиты на строки, а не на колонки.
			// И строки такой шапки отделяются спецсимволом(и).
			// Данные заголовка таких видов реестра "с шапкой" для нас бесполезны, т.к. содержат внутри себя
			// не только спецсимвол, но еще и название поля, которое может быть произвольным в разных видах реестров
			// - отделить название поля от данных нельзя, поэтому складываем такие строки в Заголовок, но потом не испльзуем.
			
			// В данном варианте реестра есть шапка из одной строки и она не выделена спецсимволом.
			// Различить такой заголовок можно только по количеству колонок с данными в строке
			// - их больше одной, но меньше, чем в последующих строках.
			
			// В этом варианте реестра, в строке шапки находится итоговая строка, у которой такая же суть,
			// как и у итоговой строки в подвале реестра Сбербанка - там только данные, без обозначений.
			
			// Данные такой строки отправляем в секцию Подвал - т.к. именно там программа ожидает увидеть итоговые данные.
			Результат.Подвал.Добавить(Результат.СтрокиРеестра[ИндексСтроки - 1]);
			Результат.СтрокиРеестра.Удалить(ИндексСтроки - 1);
		КонецЕсли;
		
		КоличествоКолонокВПервойСтрокеМеньше = Ложь;
		
		Результат.СтрокиРеестра.Добавить(СтрокаТекста);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ДанныеРеестраРазобрать(РеестрПострочно, ДопНастройки)
	Перем Организация, Банковскийсчет;
	
	РежимНастройки     = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(ДопНастройки, "РежимНастройки",     Ложь);
	ПроверитьНастройку = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(ДопНастройки, "ПроверитьНастройку", Ложь);
	
	Если НЕ ДопНастройки.Свойство("Организация", Организация) Тогда
		Организация = БухгалтерскийУчетПереопределяемый.ПолучитьЗначениеПоУмолчанию("ОсновнаяОрганизация");
	КонецЕсли;
	
	Если Не ДопНастройки.Свойство("БанковскийСчет", БанковскийСчет) Тогда
		БанковскийСчет = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Организация, "ОсновнойБанковскийСчет");
	КонецЕсли;
	
	РеквизитыРеестра = НовыйВозможныеРеквизитыКолонокРеестра();
	ДополнительныеРеквизиты = ОбщегоНазначения.ВыгрузитьКолонку(ДополнительныеРеквизитыРеестра(БанковскийСчет), "Код");
	
	ОбщегоНазначенияКлиентСервер.ДополнитьМассив(
		РеквизитыРеестра,
		ДополнительныеРеквизиты);
	
	Результат = НовыйРезультатЧтенияРеестра();
	Результат.НастройкаЗаполнения.РежимНастройки = РежимНастройки;
	
	ЗаполнитьЗначенияСвойств(Результат.НастройкаЗаполнения, РеестрПострочно, "НачалоСтрокРеестра, ОкончаниеСтрокРеестра");
	
	СохраненныеНастройкиКолонок = СохраненноеСоответствиеИменКолонокЗагружаемымДанным(БанковскийСчет);
	Если ЗначениеЗаполнено(СохраненныеНастройкиКолонок) Тогда
		ИндексыКолонокРеестра = ИндексыКолонокРеестра(СохраненныеНастройкиКолонок);
	Иначе
		Если ПроверитьНастройку Тогда
			Возврат НайтиКолонкиРеестра(РеестрПострочно, РежимНастройки,, Организация);
		Иначе // что-то пошло не так - после настройки такого быть не должно
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	
	ДанныеРеестра  = ДанныеИзСтрокРеестра(РеестрПострочно);
	СтрокиРеестра  = ДанныеРеестра.СтрокиРеестра;
	ИтоговаяСтрока = ДанныеРеестра.ИтоговаяСтрока;
	Результат.НастройкаЗаполнения.Разделитель = ДанныеРеестра.Разделитель;
	
	КоличествоСтрок = СтрокиРеестра.Количество();
	// в реестре должна быть как минимум 1 строка
	Если КоличествоСтрок = 0 Тогда
		Возврат Результат;
	КонецЕсли;
	
	КоличествоКолонокДопреквизиты = 0;
	Для каждого ИмяРеквизита Из ДополнительныеРеквизиты Цикл
		Если ИндексРеквизита(ИндексыКолонокРеестра,ИмяРеквизита) <> Неопределено Тогда
			КоличествоКолонокДопреквизиты = КоличествоКолонокДопреквизиты + 1;
		КонецЕсли; 
	КонецЦикла; 
	
	
	ТаблицаОплат = НовыйТаблицаОплат();
	КоличествоКолонок = 0;
	Для инд = 0 По КоличествоСтрок - 1 Цикл
		Данные = СтрокиРеестра[инд];
		
		КоличествоКолонокВСтроке = Данные.Количество();
		Если ПустаяСтрока(Данные[КоличествоКолонокВСтроке - 1]) Тогда
			КоличествоКолонокВСтроке = КоличествоКолонокВСтроке - 1;
		КонецЕсли;
		
		КоличествоКолонок = Макс(КоличествоКолонок, КоличествоКолонокВСтроке);
		
		// Должны быть минимум колонки по количеству допреквизитов
		Если КоличествоКолонок <  КоличествоКолонокДопреквизиты Тогда // это не реестр
			Возврат Результат;
		КонецЕсли;
		
		Если РежимНастройки Тогда
			Прервать;
		КонецЕсли;
		
		Если ПроверитьНастройку И КоличествоКолонок <> СохраненныеНастройкиКолонок["КоличествоКолонок"] Тогда
			Возврат НайтиКолонкиРеестра(РеестрПострочно, РежимНастройки, Истина, Организация, БанковскийСчет);
		КонецЕсли;
		
		ЗаполнятьСуммыНеПоФормату = Не (РежимНастройки И ПроверитьНастройку);
		РеквизитыСтрокиТаблицы = ЗаполнитьРеквизитыСтрокиТаблицы(Данные, ИндексыКолонокРеестра, РеквизитыРеестра, ЗаполнятьСуммыНеПоФормату);
		
		ВНастройкахЕстьДатаПлатежа = ИндексРеквизита(ИндексыКолонокРеестра, "ДатаПлатежа") <> Неопределено;
		СохраненнаяНастройкаНеВалидна = Не ЗначениеЗаполнено(РеквизитыСтрокиТаблицы.СуммаПлатежа)
			Или Не ЗначениеЗаполнено(РеквизитыСтрокиТаблицы.ДатаПлатежа) И ВНастройкахЕстьДатаПлатежа;
		Если ПроверитьНастройку
			И Не РеквизитыСтрокиТаблицы.ФорматСбербанка
			И СохраненнаяНастройкаНеВалидна Тогда
			Возврат НайтиКолонкиРеестра(РеестрПострочно, РежимНастройки, Истина, Организация);
		КонецЕсли;
		
		НоваяОплата = ТаблицаОплат.Добавить();
		
		НоваяОплата.ДатаОплаты         = РеквизитыСтрокиТаблицы.ДатаПлатежа;
		НоваяОплата.Сумма              = РеквизитыСтрокиТаблицы.СуммаПлатежа;
		НоваяОплата.КомиссияБанка      = РеквизитыСтрокиТаблицы.КомиссияБанка;
		
		НоваяОплата.ДополнительныеРеквизиты = Новый Структура;
		Для каждого Реквизит Из ДополнительныеРеквизиты Цикл
			НоваяОплата.ДополнительныеРеквизиты.Вставить(Реквизит, 
				ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(РеквизитыСтрокиТаблицы, Реквизит, ""));
		КонецЦикла; 
		
	КонецЦикла;
	
	ЗаполнитьСведенияОПлательщикеПоРеквизитам(Организация, БанковскийСчет, ТаблицаОплат, КоличествоКолонокДопреквизиты);
	
	ЗначенияЗаполнения = Новый Структура;
	ЗначенияЗаполнения.Вставить("Организация",    Организация);
	ЗначенияЗаполнения.Вставить("БанковскийСчет", БанковскийСчет);
	
	Если РежимНастройки Или ПроверитьНастройку Тогда
		Результат.НастройкаЗаполнения.ИндексыКолонокРеестра = ИндексыКолонокРеестра;
		Результат.НастройкаЗаполнения.СброситьНастройку = Не РежимНастройки;
	Иначе
		ЗначенияЗаполнения.Вставить("Оплаты", ОбщегоНазначения.ТаблицаЗначенийВМассив(ТаблицаОплат));
		
		ДанныеВыпискиБанка = ДанныеВыпискиБанка(ИтоговаяСтрока, Организация, БанковскийСчет);
		ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(ЗначенияЗаполнения, ДанныеВыпискиБанка);
	КонецЕсли;
	
	Результат.ЗначенияЗаполнения = ЗначенияЗаполнения;
	Результат.ЭтоРеестр = Истина;
	
	Возврат Результат;
	
КонецФункции

Процедура ЗаполнитьСведенияОПлательщикеПоРеквизитам(Организация, БанковскийСчет, ТаблицаОплат, КоличествоРеквизитов)
	
	СоответвиеРеквизитыТаблицыОплат = НОвый Соответствие;
	
	ЗначенияРеквизитов = Новый ТаблицаЗначений;
	ЗначенияРеквизитов.Колонки.Добавить("ИдентификаторПлатежа", ОбщегоНазначения.ОписаниеТипаСтрока(40));
	ЗначенияРеквизитов.Колонки.Добавить("ДатаОплаты",          Новый ОписаниеТипов("Дата"));
	ЗначенияРеквизитов.Колонки.Добавить("Идентификатор",        ОбщегоНазначения.ОписаниеТипаСтрока(25));
	ЗначенияРеквизитов.Колонки.Добавить("Значение",             ОбщегоНазначения.ОписаниеТипаСтрока(100));
	
	Для каждого СтрокаОплаты Из ТаблицаОплат Цикл
		ИдентификаторПлатежа = Строка(Новый УникальныйИдентификатор);
		СоответвиеРеквизитыТаблицыОплат.Вставить(ИдентификаторПлатежа, СтрокаОплаты);
		
		Для каждого Реквизит Из СтрокаОплаты.ДополнительныеРеквизиты Цикл
			Если Реквизит.Значение = Неопределено Тогда
				Продолжить;
			КонецЕсли; 
			
			НоваяСтрока = ЗначенияРеквизитов.Добавить();
			НоваяСтрока.ИдентификаторПлатежа = ИдентификаторПлатежа;
			НоваяСтрока.ДатаОплаты   = СтрокаОплаты.ДатаОплаты;
			НоваяСтрока.Идентификатор = Реквизит.Ключ;
			НоваяСтрока.Значение      = Реквизит.Значение;
		КонецЦикла; 
	КонецЦикла;
	
	Если ЗначенияРеквизитов.Количество() = 0 Тогда
		Возврат;
	КонецЕсли; 
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	
	Запрос.УстановитьПараметр("Организация",          Организация);
	Запрос.УстановитьПараметр("БанковскийСчет",       БанковскийСчет);
	Запрос.УстановитьПараметр("ЗначенияРеквизитов",   ЗначенияРеквизитов);
	Запрос.УстановитьПараметр("КоличествоРеквизитов", КоличествоРеквизитов);
			
	
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ЗначенияРеквизитов.ИдентификаторПлатежа КАК ИдентификаторПлатежа,
	|	ЗначенияРеквизитов.ДатаОплаты КАК ДатаОплаты,
	|	ЗначенияРеквизитов.Идентификатор КАК Идентификатор,
	|	ЗначенияРеквизитов.Значение КАК Значение
	|ПОМЕСТИТЬ ВТ_ЗначенияРеквизитов
	|ИЗ
	|	&ЗначенияРеквизитов КАК ЗначенияРеквизитов
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	ИдентификаторПлатежа
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ЗначенияРеквизитов.ИдентификаторПлатежа КАК ИдентификаторПлатежа,
	|	ЗначенияРеквизитов.ДатаОплаты КАК ДатаОплаты,
	|	СправочникРеквизитыКодаДляОплаты.Ссылка КАК РеквизитСсылка,
	|	ЗначенияРеквизитов.Значение КАК Значение
	|ПОМЕСТИТЬ ВТ_ЗначенияРеквизитовСсылка
	|ИЗ
	|	ВТ_ЗначенияРеквизитов КАК ЗначенияРеквизитов
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.РеквизитыКодаДляОплаты КАК СправочникРеквизитыКодаДляОплаты
	|		ПО ЗначенияРеквизитов.Идентификатор = СправочникРеквизитыКодаДляОплаты.Код
	|			И (СправочникРеквизитыКодаДляОплаты.Владелец = &БанковскийСчет)
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	РеквизитСсылка,
	|	Значение
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	1 КАК Очередность,
	|	ЗначенияРеквизитов.ИдентификаторПлатежа КАК ИдентификаторПлатежа,
	|	ДокументРеквизитыКодаДляОплаты.Ссылка КАК Ссылка,
	|	СчетНаОплатуПокупателю.Дата КАК Дата,
	|	СчетНаОплатуПокупателю.Контрагент КАК Контрагент,
	|	СчетНаОплатуПокупателю.ДоговорКонтрагента КАК ДоговорКонтрагента,
	|	КОЛИЧЕСТВО(РАЗЛИЧНЫЕ ДокументРеквизитыКодаДляОплаты.РеквизитКодаДляОплаты) КАК УсловийСовпадает
	|ПОМЕСТИТЬ ВТ_ДокументыПоУсловию
	|ИЗ
	|	Документ.СчетНаОплатуПокупателю КАК СчетНаОплатуПокупателю
	|		ЛЕВОЕ СОЕДИНЕНИЕ Документ.СчетНаОплатуПокупателю.РеквизитыКодаДляОплаты КАК ДокументРеквизитыКодаДляОплаты
	|		ПО СчетНаОплатуПокупателю.Ссылка = ДокументРеквизитыКодаДляОплаты.Ссылка
	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТ_ЗначенияРеквизитовСсылка КАК ЗначенияРеквизитов
	|		ПО (ДокументРеквизитыКодаДляОплаты.РеквизитКодаДляОплаты = ЗначенияРеквизитов.РеквизитСсылка)
	|			И (ЗначенияРеквизитов.Значение = ДокументРеквизитыКодаДляОплаты.Значение)
	|ГДЕ
	|	СчетНаОплатуПокупателю.Организация = &Организация
	|	И СчетНаОплатуПокупателю.СтруктурнаяЕдиница = &БанковскийСчет
	|	И СчетНаОплатуПокупателю.Дата <= ЗначенияРеквизитов.ДатаОплаты
	|	И НЕ ЗначенияРеквизитов.РеквизитСсылка ЕСТЬ NULL
	|	И НЕ СчетНаОплатуПокупателю.ПометкаУдаления
	|
	|СГРУППИРОВАТЬ ПО
	|	ДокументРеквизитыКодаДляОплаты.Ссылка,
	|	СчетНаОплатуПокупателю.Контрагент,
	|	СчетНаОплатуПокупателю.ДоговорКонтрагента,
	|	СчетНаОплатуПокупателю.Дата,
	|	ЗначенияРеквизитов.ИдентификаторПлатежа
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	2,
	|	ЗначенияРеквизитов.ИдентификаторПлатежа,
	|	ОплатаПлатежнойКартой.Ссылка,
	|	ОплатаПлатежнойКартой.Дата,
	|	ОплатаПлатежнойКартой.Контрагент,
	|	ОплатаПлатежнойКартой.ДоговорКонтрагента,
	|	КОЛИЧЕСТВО(РАЗЛИЧНЫЕ ДокументРеквизитыКодаДляОплаты.РеквизитРеестра)
	|ИЗ
	|	Документ.ОплатаПлатежнойКартой КАК ОплатаПлатежнойКартой
	|		ЛЕВОЕ СОЕДИНЕНИЕ Документ.ОплатаПлатежнойКартой.РеквизитыРеестра КАК ДокументРеквизитыКодаДляОплаты
	|		ПО ОплатаПлатежнойКартой.Ссылка = ДокументРеквизитыКодаДляОплаты.Ссылка
	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТ_ЗначенияРеквизитовСсылка КАК ЗначенияРеквизитов
	|		ПО (ДокументРеквизитыКодаДляОплаты.РеквизитРеестра = ЗначенияРеквизитов.РеквизитСсылка)
	|			И (ЗначенияРеквизитов.Значение = ДокументРеквизитыКодаДляОплаты.Значение)
	|ГДЕ
	|	ОплатаПлатежнойКартой.Организация = &Организация
	|	И ОплатаПлатежнойКартой.БанковскийСчет = &БанковскийСчет
	|	И ОплатаПлатежнойКартой.ВидОперации = ЗНАЧЕНИЕ(Перечисление.ВидыОперацийОплатаПлатежнойКартой.ПлатежПоРеестру)
	|	И ОплатаПлатежнойКартой.Дата <= ЗначенияРеквизитов.ДатаОплаты
	|	И НЕ ЗначенияРеквизитов.РеквизитСсылка ЕСТЬ NULL
	|	И НЕ ОплатаПлатежнойКартой.ПометкаУдаления
	|
	|СГРУППИРОВАТЬ ПО
	|	ОплатаПлатежнойКартой.Ссылка,
	|	ОплатаПлатежнойКартой.Контрагент,
	|	ОплатаПлатежнойКартой.ДоговорКонтрагента,
	|	ОплатаПлатежнойКартой.Дата,
	|	ЗначенияРеквизитов.ИдентификаторПлатежа
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	ИдентификаторПлатежа
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТ_ДокументыПоУсловию.ИдентификаторПлатежа КАК ИдентификаторПлатежа,
	|	МИНИМУМ(ВТ_ДокументыПоУсловию.Очередность) КАК Очередность
	|ПОМЕСТИТЬ ВТ_СрезПервыхОчередность
	|ИЗ
	|	ВТ_ДокументыПоУсловию КАК ВТ_ДокументыПоУсловию
	|ГДЕ
	|	ВТ_ДокументыПоУсловию.УсловийСовпадает = &КоличествоРеквизитов
	|
	|СГРУППИРОВАТЬ ПО
	|	ВТ_ДокументыПоУсловию.ИдентификаторПлатежа
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТ_ДокументыПоУсловию.ИдентификаторПлатежа КАК ИдентификаторПлатежа,
	|	ВТ_ДокументыПоУсловию.Очередность КАК Очередность,
	|	МАКСИМУМ(ВТ_ДокументыПоУсловию.Дата) КАК Дата
	|ПОМЕСТИТЬ ВТ_СрезПоследнихДата
	|ИЗ
	|	ВТ_СрезПервыхОчередность КАК ВТ_СрезПервыхОчередность
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ВТ_ДокументыПоУсловию КАК ВТ_ДокументыПоУсловию
	|		ПО ВТ_СрезПервыхОчередность.ИдентификаторПлатежа = ВТ_ДокументыПоУсловию.ИдентификаторПлатежа
	|			И ВТ_СрезПервыхОчередность.Очередность = ВТ_ДокументыПоУсловию.Очередность
	|ГДЕ
	|	ВТ_ДокументыПоУсловию.УсловийСовпадает = &КоличествоРеквизитов
	|
	|СГРУППИРОВАТЬ ПО
	|	ВТ_ДокументыПоУсловию.ИдентификаторПлатежа,
	|	ВТ_ДокументыПоУсловию.Очередность
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТ_ДокументыПоУсловию.ИдентификаторПлатежа КАК ИдентификаторПлатежа,
	|	ВТ_ДокументыПоУсловию.Очередность КАК Очередность,
	|	ВТ_ДокументыПоУсловию.Дата КАК Дата,
	|	МАКСИМУМ(ВТ_ДокументыПоУсловию.Ссылка) КАК Ссылка
	|ПОМЕСТИТЬ ВТ_СрезПоследнихСсылка
	|ИЗ
	|	ВТ_СрезПоследнихДата КАК ВТ_СрезПоследнихДата
	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТ_ДокументыПоУсловию КАК ВТ_ДокументыПоУсловию
	|		ПО ВТ_СрезПоследнихДата.ИдентификаторПлатежа = ВТ_ДокументыПоУсловию.ИдентификаторПлатежа
	|			И ВТ_СрезПоследнихДата.Дата = ВТ_ДокументыПоУсловию.Дата
	|			И ВТ_СрезПоследнихДата.Очередность = ВТ_ДокументыПоУсловию.Очередность
	|ГДЕ
	|	ВТ_ДокументыПоУсловию.УсловийСовпадает = &КоличествоРеквизитов
	|
	|СГРУППИРОВАТЬ ПО
	|	ВТ_ДокументыПоУсловию.ИдентификаторПлатежа,
	|	ВТ_ДокументыПоУсловию.Очередность,
	|	ВТ_ДокументыПоУсловию.Дата
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТ_ДокументыПоУсловию.ИдентификаторПлатежа КАК ИдентификаторПлатежа,
	|	ВТ_ДокументыПоУсловию.Контрагент КАК Контрагент,
	|	ВТ_ДокументыПоУсловию.ДоговорКонтрагента КАК ДоговорКонтрагента,
	|	ВЫРАЗИТЬ(ВТ_ДокументыПоУсловию.Ссылка КАК Документ.СчетНаОплатуПокупателю) КАК Основание
	|ИЗ
	|	ВТ_СрезПоследнихСсылка КАК ВТ_СрезПоследнихСсылка
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ВТ_ДокументыПоУсловию КАК ВТ_ДокументыПоУсловию
	|		ПО ВТ_СрезПоследнихСсылка.ИдентификаторПлатежа = ВТ_ДокументыПоУсловию.ИдентификаторПлатежа
	|			И ВТ_СрезПоследнихСсылка.Очередность = ВТ_ДокументыПоУсловию.Очередность
	|			И ВТ_СрезПоследнихСсылка.Дата = ВТ_ДокументыПоУсловию.Дата
	|			И ВТ_СрезПоследнихСсылка.Ссылка = ВТ_ДокументыПоУсловию.Ссылка";
	
	
	РезультатЗапроса = Запрос.Выполнить().Выбрать();
	
	Пока РезультатЗапроса.Следующий() Цикл
		СтрокаОплаты = СоответвиеРеквизитыТаблицыОплат[РезультатЗапроса.ИдентификаторПлатежа];
		
		Если СтрокаОплаты <> Неопределено Тогда
			ЗаполнитьЗначенияСвойств(СтрокаОплаты, РезультатЗапроса);
		КонецЕсли; 
	КонецЦикла; 
КонецПроцедуры

Процедура ВыделитьКолонкиСуммаПлатежаКомиссияБанка(Данные, ИндексыКолонокРеестра, ИндексКолонки, ПорядковыйНомерСуммы)
	
	Если ПорядковыйНомерСуммы > 3 Тогда
		// Все суммы найдены, либо их слишком много и нельзя выбрать требуемые.
		Возврат;
	КонецЕсли;
	
	ИмяРеквизитаСумма = "СуммаПлатежа";
	РеквизитСумма = ПолучитьЗначениеРеквизита(Данные[ИндексКолонки], ИмяРеквизитаСумма);
	Если РеквизитСумма = Неопределено Тогда
		Если ПорядковыйНомерСуммы > 0 И ПорядковыйНомерСуммы < 3 Тогда
			// В процессе обхода нашли какую-то сумму (возможно Сумму платежа),
			// но не нашли три подряд идущие суммовые колонки (как в формате Сбербанка).
			// Значит Комиссию банка в таком формате мы не определеяем, только сумму платежа.
			// Проверим колонки с суммами и зафиксируем ту, которая подходит.
			Для Счетчик = 1 По ПорядковыйНомерСуммы Цикл
				ПредыдущийПроверенныйИндекс = ИндексКолонки + Счетчик;
				ПредыдущийРеквизит = ПолучитьЗначениеРеквизита(Данные[ПредыдущийПроверенныйИндекс], ИмяРеквизитаСумма);
				
				// Сумма платежа по взносу не может быть нулевой.
				Если ПредыдущийРеквизит > 0 Тогда
					ИндексыКолонокРеестра.Вставить(ПредыдущийПроверенныйИндекс, ИмяРеквизитаСумма);
					ПорядковыйНомерСуммы = 4; // Превысим границу счетчика, чтобы суммы больше не проверялись.
					Прервать;
				ИначеЕсли Счетчик = ПорядковыйНомерСуммы Тогда
					// Сбросим счетчик, чтобы искать сумму дальше, т.к. найденные суммы не прошли проверку.
					ПорядковыйНомерСуммы = 0;
				КонецЕсли;
			КонецЦикла;
			
			Возврат;
		КонецЕсли;
	Иначе
		ПорядковыйНомерСуммы = ПорядковыйНомерСуммы + 1;
	КонецЕсли;
	
	// Если нашли 3 колонки подряд с суммами, то возможно это реестр Сбербанка, необходима дополнительная проверка.
	Если ПорядковыйНомерСуммы = 3 Тогда
		// Запомним индекс колонок Сумма платежа и Комиссия банка (если что, сбросим их после проверки).
		ИндексыКолонокРеестра.Вставить(ИндексКолонки, ИмяРеквизитаСумма);
		ИндексыКолонокРеестра.Вставить(ИндексКолонки + 2, "КомиссияБанка");
		
		Реквизиты = НовыйВозможныеРеквизитыКолонокРеестра();
		
		// Проверим соотношение найденных суммм по формату Сбербанка.
		РеквизитыСтрокиТаблицы = ЗаполнитьРеквизитыСтрокиТаблицы(Данные, ИндексыКолонокРеестра, Реквизиты);
		
		Если Не РеквизитыСтрокиТаблицы.ФорматСбербанка Тогда
			// Соотношение сумм не соответствует формату Сбербанка,
			// сбросим индекс Комиссии банка - т.к. в других форматах этой колонки может не быть.
			ИндексыКолонокРеестра.Удалить(ИндексКолонки + 2); // Комиссия банка
			
			// Сохраним индекс только на колонку с возможной Суммой платежа,
			// если мы ошиблись, пользователь ее переопределит.
			Если Не ЗначениеЗаполнено(РеквизитыСтрокиТаблицы.СуммаПлатежа) Тогда
				// Сумма платежа по взносу не может быть нулевой, значит это не колонка с Суммой платежа.
				ИндексыКолонокРеестра.Удалить(ИндексКолонки); // Сумма платежа
			КонецЕсли;
		КонецЕсли;
		
		// Превысим границу счетчика, чтобы больше суммы не проверялись.
		// Даже если суммы не прошли проверку (и мы их исключили), дальше искать не имеет смысла - в реестре
		// уже найдено слишком много колонок с суммами, мы не можем определить какая из них является Суммой платежа,
		// пусть пользователь выберет сам.
		ПорядковыйНомерСуммы = 4;
	КонецЕсли;
	
КонецПроцедуры

Процедура ВыделитьКолонкуДатаПлатежа(Данные, ИндексыКолонокРеестра, ИндексКолонки)
	
	ИмяРеквизитаДата = "ДатаПлатежа";
	Если ИндексРеквизита(ИндексыКолонокРеестра, ИмяРеквизитаДата) = Неопределено И ИндексКолонки > 0 Тогда
		// При проверке на формат Сбербанка не нашли дату в первой колонке, попробуем найти в остальных (не суммовых).
		ДатаПлатежа = ПолучитьЗначениеРеквизита(Данные[ИндексКолонки], ИмяРеквизитаДата);
		Если ДатаПлатежа <> Неопределено Тогда
			ИндексыКолонокРеестра.Вставить(ИндексКолонки, ИмяРеквизитаДата);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Процедура ОпределитьНазначениеКолонокПоДаннымВПервойСтроке(Данные, ГраницаКолонок, ИндексыКолонокРеестра)
	
	ПорядковыйНомерСуммы = 0;
	Для ОбратныйИндексКолонки = 0 По ГраницаКолонок Цикл
		ИндексКолонки = ГраницаКолонок - ОбратныйИндексКолонки;
		
		ВыделитьКолонкиСуммаПлатежаКомиссияБанка(Данные, ИндексыКолонокРеестра, ИндексКолонки, ПорядковыйНомерСуммы);
		
		Если ИндексыКолонокРеестра[ИндексКолонки] <> Неопределено Тогда
			// Данный индекс уже проверен и определен, проверять на дату смысла нет.
			Продолжить;
		КонецЕсли;
		
		ВыделитьКолонкуДатаПлатежа(Данные, ИндексыКолонокРеестра, ИндексКолонки);
	КонецЦикла;
	
КонецПроцедуры

Функция НайтиКолонкиРеестра(РеестрПострочно, РежимНастройки, СброситьНастройку = Ложь, Организация = Неопределено, БанковскийСчет = Неопределено)
	
	Результат = НовыйРезультатЧтенияРеестра();
	Результат.НастройкаЗаполнения.РежимНастройки = РежимНастройки;
	
	ДанныеРеестра  = ДанныеИзСтрокРеестра(РеестрПострочно);
	СтрокиРеестра  = ДанныеРеестра.СтрокиРеестра;
	ИтоговаяСтрока = ДанныеРеестра.ИтоговаяСтрока;
	Результат.НастройкаЗаполнения.Разделитель = ДанныеРеестра.Разделитель;
	
	КоличествоСтрок = СтрокиРеестра.Количество();
	Если КоличествоСтрок = 0 Тогда
		Возврат Результат;
	КонецЕсли;
	
	КоличествоКолонок = 0;
	ИндексыКолонокРеестра = Новый Соответствие;
	Для инд = 0 По КоличествоСтрок - 1 Цикл
		Данные = СтрокиРеестра[инд];
		
		КоличествоКолонокВСтроке = Данные.Количество();
		Если ПустаяСтрока(Данные[КоличествоКолонокВСтроке - 1]) Тогда
			КоличествоКолонокВСтроке = КоличествоКолонокВСтроке - 1;
		КонецЕсли;
		
		КоличествоКолонок = Макс(КоличествоКолонок, КоличествоКолонокВСтроке);
		ГраницаКолонок = КоличествоКолонок - 1;
		
		// В формате Сбербанка:
		// - в первой колонке содержится дата платежа.
		// Проверим данные в первой колонке - если там не дата, то это не формат Сбербанка.
		
		ИмяРеквизита = "ДатаПлатежа";
		ИндексКолонкиДата = 0;
		ДатаПлатежа = ПолучитьЗначениеРеквизита(Данные[ИндексКолонкиДата], ИмяРеквизита);
		НашлиКолонкуДата = ДатаПлатежа <> Неопределено;
		Если НашлиКолонкуДата Тогда
			ИндексыКолонокРеестра.Вставить(ИндексКолонкиДата, ИмяРеквизита);
		КонецЕсли;
		
		// В формате Сбербанка:
		//  - в последних 3 колонках (возможно с сдвигом на 1 колонку) находятся суммы:
		// Сумма оплаты, Сумма без комиссии, Комиссия банка, в формате: [руб],[коп]
		// Поэтому колонку с Суммой платежа будем искать "с конца".
		// Если найдем 3 идущих подряд числовые колонки, которые подчиняются правилу
		//  [Сумма платежа] = [Сумма без комиссии] + [Комиссия банка]
		// - значит это формат Сбербанка.
		// Иначе найдем первую колонку с суммой, которую и будем считать Суммой платежа.
		//
		// Выделение колонок производим только в первой строке,
		// в остальных строках проверяем соответствие настройкам, выделенным из первой.
		
		Если инд = 0 Тогда
			ОпределитьНазначениеКолонокПоДаннымВПервойСтроке(Данные, ГраницаКолонок, ИндексыКолонокРеестра);
		Иначе
			Реквизиты = НовыйВозможныеРеквизитыКолонокРеестра();
			Для ОбратныйИндексКолонки = 0 По ГраницаКолонок Цикл
				Если ИндексыКолонокРеестра.Количество() = 0 Тогда
					Прервать;
				КонецЕсли;
				
				ИндексКолонки = ГраницаКолонок - ОбратныйИндексКолонки;
				ИмяРеквизита  = ИндексыКолонокРеестра[ИндексКолонки];
				Если Реквизиты.Найти(ИмяРеквизита) <> Неопределено Тогда
					Реквизит = ПолучитьЗначениеРеквизита(Данные[ИндексКолонки], ИмяРеквизита);
					Если Реквизит = Неопределено Тогда
						// Выделенная настройка из первой строки не совпадает с данными в следующией(их) строке(ах).
						ИндексыКолонокРеестра.Удалить(ИндексКолонки);
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		Для ИндексКолонки = 0 По ГраницаКолонок Цикл
			// Данные всех неопределенных колонок заполняем для дальнейшего поиска колонки с идентификатором плательщика.
			Если ИндексыКолонокРеестра[ИндексКолонки] = Неопределено Тогда
				ИндексыКолонокРеестра.Вставить(ИндексКолонки, Новый Массив);
			КонецЕсли;
			
			Если ТипЗнч(ИндексыКолонокРеестра[ИндексКолонки]) = Тип("Массив") Тогда
				ИндексыКолонокРеестра[ИндексКолонки].Добавить(Данные[ИндексКолонки]);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	Результат.ЭтоРеестр = Истина;
	
	ЕстьСуммаПлатежа = Ложь;
	Для Каждого КлючИЗначение Из ИндексыКолонокРеестра Цикл
		Если ТипЗнч(КлючИЗначение.Значение) = Тип("Массив") Тогда
			Продолжить;
		КонецЕсли;
		
		ЕстьСуммаПлатежа = ЕстьСуммаПлатежа Или КлючИЗначение.Значение = "СуммаПлатежа";
		
		Результат.НастройкаЗаполнения.ИндексыКолонокРеестра.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
	КонецЦикла;
	
	ЗаполнитьЗначенияСвойств(
		Результат.НастройкаЗаполнения, РеестрПострочно, "НачалоСтрокРеестра, ОкончаниеСтрокРеестра");
	
	Если Не ЗначениеЗаполнено(Организация) Тогда
		Организация = БухгалтерскийУчетПереопределяемый.ПолучитьЗначениеПоУмолчанию("ОсновнаяОрганизация");
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(БанковскийСчет) Тогда
		БанковскийСчет = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Организация, "ОсновнойБанковскийСчет");
	КонецЕсли;
	
	
	Результат.НастройкаЗаполнения.СброситьНастройку = СброситьНастройку
		Или Не ЕстьСуммаПлатежа;
	
	ЗначенияЗаполнения = Новый Структура;
	ЗначенияЗаполнения.Вставить("Организация",    Организация);
	ЗначенияЗаполнения.Вставить("БанковскийСчет", БанковскийСчет);
	
	Результат.ЗначенияЗаполнения = ЗначенияЗаполнения;
	
	Возврат Результат;
	
КонецФункции

Функция РазделительСуммыИзСтандартаПочтаБанка()
	
	Возврат ".";
	
КонецФункции

Функция РазделительСуммыИзСтандартаСбербанка()
	
	Возврат ",";
	
КонецФункции

Функция ЭтоДопустимыйРазделитель(Разделитель)
	
	Возврат Разделитель = РазделительСуммыИзСтандартаСбербанка()
		Или Разделитель = РазделительСуммыИзСтандартаПочтаБанка();
	
КонецФункции

Функция РазделительИзСтроковогоПредставленияСуммы(СуммаСтр)
	
	Возврат Лев(Прав(СуммаСтр, 3), 1);
	
КонецФункции

Функция ПолучитьЗначениеРеквизитаСумма(СуммаСтр, ЗаполнятьСуммыНеПоФормату = Ложь)
	
	Сумма = Неопределено;
	Если Не ЗначениеЗаполнено(СуммаСтр) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	РазделительИзСтандарта = РазделительСуммыИзСтандартаСбербанка();
	РазделительИзСтроки = РазделительИзСтроковогоПредставленияСуммы(СуммаСтр);
	РазделительИзЛокали = РазделительИзСтроковогоПредставленияСуммы(Формат(1, "ЧДЦ=2"));
	ЛокальныйНоль = "0" + РазделительИзЛокали + "00";
	
	ТипЧисло = Новый ОписаниеТипов("Число");
	
	Если СтрЧислоВхождений(СуммаСтр, РазделительИзСтандарта) <> 1 Или РазделительИзСтроки <> РазделительИзСтандарта Тогда
		СоставСтроки = СтрРазделить(СуммаСтр, РазделительИзСтроки);
		ПохожеНаЧисло = СоставСтроки.Количество() = 2 И СтрДлина(СоставСтроки[1]) = 2
			И ЭтоДопустимыйРазделитель(РазделительИзСтроки);
		
		Если ПохожеНаЧисло Тогда
			РазделительИзСтандарта = РазделительИзСтроки;
		ИначеЕсли ЗаполнятьСуммыНеПоФормату Тогда
			Возврат ТипЧисло.ПривестиЗначение(СуммаСтр);
		Иначе
			Возврат Сумма;
		КонецЕсли;
	КонецЕсли;
	
	Если РазделительИзСтандарта <> РазделительИзЛокали Тогда
		Если СтрНайти(СуммаСтр, РазделительИзЛокали) > 0 Тогда
			Возврат Сумма;
		КонецЕсли;
		
		СуммаСтр = СтрЗаменить(СуммаСтр, РазделительИзСтандарта, РазделительИзЛокали);
	КонецЕсли;
	
	ЗначениеСуммы = ТипЧисло.ПривестиЗначение(СуммаСтр);
	Если ЗначениеЗаполнено(ЗначениеСуммы) Или СуммаСтр = ЛокальныйНоль Тогда
		Сумма = ЗначениеСуммы;
	КонецЕсли;
	
	Возврат Сумма;
	
КонецФункции

Функция ПолучитьЗначениеРеквизитаДата(ДатаПлатежа)
	
	ДатаОплаты = Неопределено;
	Если Не ЗначениеЗаполнено(ДатаПлатежа) Или СтрДлина(ДатаПлатежа) <> 10 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ЗаполненКорректно = Истина;
	Разделитель = Сред(ДатаПлатежа, 3, 1);
	ЧастиДатаОплаты = СтрРазделить(ДатаПлатежа, Разделитель, Ложь);
	Если ЧастиДатаОплаты.Количество() <> 3 Тогда
		ЗаполненКорректно = Ложь;
	ИначеЕсли СтрДлина(ЧастиДатаОплаты[0]) <> 2 Или Не СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(ЧастиДатаОплаты[0]) Тогда
		ЗаполненКорректно = Ложь;
	ИначеЕсли СтрДлина(ЧастиДатаОплаты[1]) <> 2 Или Не СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(ЧастиДатаОплаты[1]) Тогда
		ЗаполненКорректно = Ложь;
	ИначеЕсли СтрДлина(ЧастиДатаОплаты[2]) <> 4 Или Не СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(ЧастиДатаОплаты[2]) Тогда
		ЗаполненКорректно = Ложь;
	КонецЕсли;
	
	Если ЗаполненКорректно Тогда
		ТипДата = Новый ОписаниеТипов("Дата");
		ДатаОплаты = ТипДата.ПривестиЗначение(ЧастиДатаОплаты[2] + ЧастиДатаОплаты[1] + ЧастиДатаОплаты[0]);
	КонецЕсли;
	
	Возврат ДатаОплаты;
	
КонецФункции

Функция ПолучитьЗначениеРеквизита(РеквизитСтр, ИмяРеквизита, ЗаполнятьСуммыНеПоФормату = Ложь)
	
	Реквизит = Неопределено;
	Если ИмяРеквизита = "ДатаПлатежа" Тогда
		Реквизит = ПолучитьЗначениеРеквизитаДата(РеквизитСтр);
	ИначеЕсли ИмяРеквизита = "КомиссияБанка" Тогда
		Реквизит = ПолучитьЗначениеРеквизитаСумма(РеквизитСтр, ЗаполнятьСуммыНеПоФормату);
	ИначеЕсли ИмяРеквизита = "СуммаПлатежа" Тогда
		Реквизит = ПолучитьЗначениеРеквизитаСумма(РеквизитСтр, ЗаполнятьСуммыНеПоФормату);
	ИначеЕсли ИмяРеквизита = "СуммаБезКомиссии" Тогда
		Реквизит = ПолучитьЗначениеРеквизитаСумма(РеквизитСтр, ЗаполнятьСуммыНеПоФормату);
	Иначе
		Реквизит = РеквизитСтр;
	КонецЕсли;
	
	Возврат Реквизит;
	
КонецФункции

Функция ЗаполнитьРеквизитыСтрокиТаблицы(Данные, ИндексыКолонокРеестра, Реквизиты, ЗаполнятьСуммыНеПоФормату = Ложь)
	
	РеквизитыСтрокиТаблицы = Новый Структура;
	РеквизитыСтрокиТаблицы.Вставить("ФорматСбербанка", Истина);
	
	Для Каждого ИмяРеквизита Из Реквизиты Цикл
		ИндексРеквизита = ИндексРеквизита(ИндексыКолонокРеестра, ИмяРеквизита);
		Если ИндексРеквизита = Неопределено Тогда
			РеквизитСтр = Неопределено;
			Реквизит    = Неопределено;
		Иначе
			РеквизитСтр = Данные[ИндексРеквизита];
			Реквизит    = ПолучитьЗначениеРеквизита(РеквизитСтр, ИмяРеквизита);
		КонецЕсли;
		
		РеквизитыСтрокиТаблицы.ФорматСбербанка = РеквизитыСтрокиТаблицы.ФорматСбербанка
			И Реквизит <> Неопределено;
		
		Если Не РеквизитыСтрокиТаблицы.ФорматСбербанка И ЗаполнятьСуммыНеПоФормату Тогда
			Реквизит = ПолучитьЗначениеРеквизита(РеквизитСтр, ИмяРеквизита, ЗаполнятьСуммыНеПоФормату);
		КонецЕсли;
		
		РеквизитыСтрокиТаблицы.Вставить(ИмяРеквизита, Реквизит);
	КонецЦикла;
	
	// Проверим "арифметику": [Сумма платежа] = [Сумма взноса] - [Комиссия банка].
	Если РеквизитыСтрокиТаблицы.ФорматСбербанка Тогда
		ИндексКомиссииБанка = ИндексРеквизита(ИндексыКолонокРеестра, "КомиссияБанка");
		Если ИндексКомиссииБанка <> Неопределено Тогда
			ИндексСуммаБезКомиссии = ИндексКомиссииБанка - 1;
			СуммаБезКомиссииСтр = Данные[ИндексСуммаБезКомиссии];
			СуммаБезКомиссии = ПолучитьЗначениеРеквизита(СуммаБезКомиссииСтр, "СуммаПлатежа");
			Если СуммаБезКомиссии = Неопределено
				Или СуммаБезКомиссии <> РеквизитыСтрокиТаблицы.СуммаПлатежа - РеквизитыСтрокиТаблицы.КомиссияБанка Тогда
				РеквизитыСтрокиТаблицы.ФорматСбербанка = Ложь;
			КонецЕсли;
		КонецЕсли;
	Иначе
		ИндексКомиссииБанка    = ИндексРеквизита(ИндексыКолонокРеестра, "КомиссияБанка");
		ИндексСуммаПлатежа     = ИндексРеквизита(ИндексыКолонокРеестра, "СуммаПлатежа");
		ИндексСуммаБезКомиссии = ИндексРеквизита(ИндексыКолонокРеестра, "СуммаБезКомиссии");
		
		// Некоторые банки выгружают данные по сумме платежа и сумме без комиссии, но не выгружают саму комиссию банка.
		// Посчитаем её из известных данных.
		Если ИндексКомиссииБанка = Неопределено
			И ЗначениеЗаполнено(ИндексСуммаБезКомиссии) И ЗначениеЗаполнено(ИндексСуммаПлатежа) Тогда
			РеквизитыСтрокиТаблицы.КомиссияБанка = Данные[ИндексСуммаПлатежа] - Данные[ИндексСуммаБезКомиссии];
		КонецЕсли;
	КонецЕсли;
	
	Возврат РеквизитыСтрокиТаблицы;
	
КонецФункции

Функция ОписаниеЗагружаемыхКолонок(ДополнительныеРеквизиты) Экспорт
	
	ОписаниеКолонок = ЗагрузкаДанныхИзВнешнихФайлов.НовыйОписаниеЗагружаемыхКолонок();
	
	// Дата платежа
	НоваяСтрока = ОписаниеКолонок.Добавить();
	НоваяСтрока.Идентификатор = "ДатаПлатежа";
	НоваяСтрока.ПредставлениеКолонки = НСтр("ru = 'Дата платежа'");
	НоваяСтрока.ОбязательнаДляЗаполнения = Ложь;
	
	// Сумма взноса
	НоваяСтрока = ОписаниеКолонок.Добавить();
	НоваяСтрока.Идентификатор = "СуммаПлатежа";
	НоваяСтрока.ПредставлениеКолонки = НСтр("ru = 'Сумма платежа'");
	НоваяСтрока.ОбязательнаДляЗаполнения = Истина;
	
	// Сумма взноса без комиссии
	НоваяСтрока = ОписаниеКолонок.Добавить();
	НоваяСтрока.Идентификатор = "СуммаБезКомиссии";
	НоваяСтрока.ПредставлениеКолонки = НСтр("ru = 'Сумма платежа без комиссии'");
	НоваяСтрока.ОбязательнаДляЗаполнения = Ложь;
	
	// Комиссия банка
	НоваяСтрока = ОписаниеКолонок.Добавить();
	НоваяСтрока.Идентификатор = "КомиссияБанка";
	НоваяСтрока.ПредставлениеКолонки = НСтр("ru = 'В т.ч. комиссия банка'");
	НоваяСтрока.ОбязательнаДляЗаполнения = Ложь;
	
	Для каждого РеквизитПлатежа Из ДополнительныеРеквизиты Цикл
		НоваяСтрока = ОписаниеКолонок.Добавить();
		НоваяСтрока.Идентификатор = РеквизитПлатежа.Значение;
		НоваяСтрока.ПредставлениеКолонки = РеквизитПлатежа.Представление;
		НоваяСтрока.ОбязательнаДляЗаполнения = Ложь;
	КонецЦикла; 
	
	Возврат ОписаниеКолонок;
	
КонецФункции

Функция ИндексыКолонокРеестра(НастроенныеКолонки) Экспорт
	
	Результат = Новый Соответствие;
	
	Для Каждого КлючИЗначение Из НастроенныеКолонки Цикл
		Если ТипЗнч(КлючИЗначение.Значение) <> Тип("Структура") Тогда
			Продолжить;
		КонецЕсли;
		Результат.Вставить(КлючИЗначение.Ключ - 1, КлючИЗначение.Значение.Идентификатор);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ДанныеВыпискиБанка(ИтоговаяСтрока, Организация, Банковскийсчет)
	Результат = Новый Структура;
	
	ДанныеСтроки = СтрРазделить(ИтоговаяСтрока, ";", Ложь);
	КоличествоСтрок = ДанныеСтроки.Количество();
	
	Если КоличествоСтрок = 0 Тогда
		Возврат Результат;
	КонецЕсли;
	
	ДатаВходящегоДокумента  = ПолучитьЗначениеРеквизитаДата(ДанныеСтроки[КоличествоСтрок - 1]);
	НомерВходящегоДокумента = ДанныеСтроки[КоличествоСтрок - 2];
	
	Если ДатаВходящегоДокумента = Неопределено 
		ИЛИ ПолучитьЗначениеРеквизитаСумма(НомерВходящегоДокумента) <> Неопределено Тогда
		
		Возврат Результат;
	КонецЕсли;
	
	Результат.Вставить("НомерВходящегоДокумента", НомерВходящегоДокумента);
	Результат.Вставить("ДатаВходящегоДокумента",  ДатаВходящегоДокумента);
	
	Запрос = Новый Запрос;
	
	Запрос.УстановитьПараметр("Организация",             Организация);
	Запрос.УстановитьПараметр("БанковскийСчет",          БанковскийСчет);
	Запрос.УстановитьПараметр("НомерВходящегоДокумента", НомерВходящегоДокумента);
	Запрос.УстановитьПараметр("ДатаВходящегоДокумента",  ДатаВходящегоДокумента);
	
	Запрос.Текст =
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	ПоступлениеНаРасчетныйСчет.Контрагент КАК Контрагент,
	|	ПоступлениеНаРасчетныйСчет.ДоговорКонтрагента КАК ДоговорКонтрагента,
	|	ПоступлениеНаРасчетныйСчет.Ссылка КАК ПоступлениеНаРасчетныйСчет,
	|	ПоступлениеНаРасчетныйСчет.Дата КАК ДатаВыписки
	|ИЗ
	|	Документ.ПоступлениеНаРасчетныйСчет КАК ПоступлениеНаРасчетныйСчет
	|ГДЕ
	|	ПоступлениеНаРасчетныйСчет.Организация = &Организация
	|	И ПоступлениеНаРасчетныйСчет.НомерВходящегоДокумента = &НомерВходящегоДокумента
	|	И ПоступлениеНаРасчетныйСчет.ДатаВходящегоДокумента = &ДатаВходящегоДокумента
	|	И НЕ ПоступлениеНаРасчетныйСчет.ПометкаУдаления
	|	И ПоступлениеНаРасчетныйСчет.СчетОрганизации = &БанковскийСчет";
	
	Реквизиты = Запрос.Выполнить().Выгрузить();
	Если Реквизиты.Количество() = 1 Тогда
		ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(
			Результат,
			ОбщегоНазначения.СтрокаТаблицыЗначенийВСтруктуру(Реквизиты[0]));
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ВариантыРазделителяCSV()
	
	Результат = Новый Массив;
	Результат.Добавить(";");
	Результат.Добавить("|");
	
	Возврат Результат;
	
КонецФункции

Функция ВыделитьРазделитель(СтрокаРеестра)
	Результат = ";";
	
	Разделители = ВариантыРазделителяCSV();
	МаксКоличествоПозицийРазделителя = 0;
	ИндексРазделителя = 0;
	Индекс = 0;
	Для Каждого Разделитель Из Разделители Цикл
		КоличествоПозицийРазделителя = СтрЧислоВхождений(СтрокаРеестра, Разделитель);
		Если КоличествоПозицийРазделителя > МаксКоличествоПозицийРазделителя Тогда
			МаксКоличествоПозицийРазделителя = КоличествоПозицийРазделителя;
			ИндексРазделителя = Индекс;
		КонецЕсли;
		
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Если МаксКоличествоПозицийРазделителя <> 0 Тогда
		Результат = Разделители[ИндексРазделителя];
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ДанныеИзСтрокРеестра(ДанныеРеестра)
	
	Результат = НовыйДанныеРеестра();
	Если ДанныеРеестра.СтрокиРеестра.Количество() = 0 Тогда
		Возврат Результат;
	КонецЕсли;
	
	Результат.Разделитель = ВыделитьРазделитель(ДанныеРеестра.СтрокиРеестра[0]);
	
	ПустыеКолонкиСтрок = Новый Соответствие;
	
	ИндексСтроки = 0;
	Для Каждого СтрокаТекста Из ДанныеРеестра.СтрокиРеестра Цикл
		Данные = СтрРазделить(СтрокаТекста, Результат.Разделитель, Истина);
		НайтиПустыеКолонки(Данные, ПустыеКолонкиСтрок, ИндексСтроки);
		Результат.СтрокиРеестра.Добавить(Данные);
		
		ИндексСтроки = ИндексСтроки + 1;
	КонецЦикла;
	
	Если ДанныеРеестра.Подвал.Количество() = 1 Тогда
		Результат.ИтоговаяСтрока = ДанныеРеестра.Подвал[0];
	КонецЕсли;
	
	УдалитьПустыеКолонки(Результат.СтрокиРеестра, ПустыеКолонкиСтрок);
	
	Возврат Результат;
	
КонецФункции

Функция ПустыеКолонки(ПустыеКолонкиСтрок)
	
	Результат = Новый СписокЗначений;
	Для Каждого КлючИЗначение Из ПустыеКолонкиСтрок Цикл
		Если КлючИЗначение.Значение Тогда
			Результат.Добавить(КлючИЗначение.Ключ);
		КонецЕсли;
	КонецЦикла;
	
	Результат.СортироватьПоЗначению(НаправлениеСортировки.Убыв);
	
	Возврат Результат.ВыгрузитьЗначения();
	
КонецФункции

Функция НовыйРезультатЧтенияРеестра()
	
	Результат = Новый Структура;
	Результат.Вставить("ЗначенияЗаполнения",  Новый Структура);
	Результат.Вставить("НастройкаЗаполнения", НовыйНастройкаЗаполнения());
	Результат.Вставить("ЭтоРеестр",           Ложь);
	
	Возврат Результат;
	
КонецФункции

Функция НовыйНастройкаЗаполнения()
	
	Результат = Новый Структура;
	Результат.Вставить("СброситьНастройку", Ложь);
	Результат.Вставить("РежимНастройки", Ложь);
	Результат.Вставить("ИндексыКолонокРеестра", Новый Соответствие);
	Результат.Вставить("НачалоСтрокРеестра");
	Результат.Вставить("ОкончаниеСтрокРеестра");
	Результат.Вставить("Разделитель");
	
	Возврат Результат;
	
КонецФункции

Функция НовыйТаблицаОплат()
	
	ТаблицаОплат = Новый ТаблицаЗначений;
	ТаблицаОплат.Колонки.Добавить("ДатаОплаты",           ОбщегоНазначения.ОписаниеТипаДата(ЧастиДаты.Дата));
	ТаблицаОплат.Колонки.Добавить("Контрагент",           Новый ОписаниеТипов("СправочникСсылка.Контрагенты"));
	ТаблицаОплат.Колонки.Добавить("ДоговорКонтрагента",   Новый ОписаниеТипов("СправочникСсылка.ДоговорыКонтрагентов"));
	ТаблицаОплат.Колонки.Добавить("Основание",            Новый ОписаниеТипов("ДокументСсылка.СчетНаОплатуПокупателю"));
	ТаблицаОплат.Колонки.Добавить("Сумма",                ОбщегоНазначения.ОписаниеТипаЧисло(15, 2));
	ТаблицаОплат.Колонки.Добавить("СуммаБезКомиссии",     ОбщегоНазначения.ОписаниеТипаЧисло(15, 2));
	ТаблицаОплат.Колонки.Добавить("КомиссияБанка",        ОбщегоНазначения.ОписаниеТипаЧисло(15, 2));
	ТаблицаОплат.Колонки.Добавить("ДополнительныеРеквизиты");
	
	Возврат ТаблицаОплат;
КонецФункции

Функция НовыйДанныеРеестра()
	
	Результат = Новый Структура;
	Результат.Вставить("СтрокиРеестра", Новый Массив);
	Результат.Вставить("ИтоговаяСтрока");
	Результат.Вставить("Разделитель");
	
	Возврат Результат;
	
КонецФункции

Процедура НайтиПустыеКолонки(Данные, ПустыеКолонки, ИндексСтроки)
	
	Для инд = 0 По Данные.Количество() - 1 Цикл
		Если ПустаяСтрока(Данные[инд]) И ПустыеКолонки[инд] = Неопределено Тогда
			ПустыеКолонки.Вставить(инд, ИндексСтроки = 0);
		ИначеЕсли ПустыеКолонки[инд] <> Неопределено Тогда
			ПустыеКолонки[инд] = ПустыеКолонки[инд] И ПустаяСтрока(Данные[инд]);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Процедура УдалитьПустыеКолонки(СтрокиРеестра, ПустыеКолонкиСтрок)
	
	ПустыеКолонки = ПустыеКолонки(ПустыеКолонкиСтрок);
	
	Для Каждого Данные Из СтрокиРеестра Цикл
		Для Каждого инд Из ПустыеКолонки Цикл
			Если инд < Данные.Количество() Тогда
				Данные.Удалить(инд);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

Функция ИндексРеквизита(ИндексыКолонокРеестра, ИмяРеквизита)
	
	Результат = Неопределено;
	Для Каждого КлючИЗначение Из ИндексыКолонокРеестра Цикл
		Если КлючИЗначение.Значение = ИмяРеквизита Тогда
			Результат = КлючИЗначение.Ключ;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция НовыйВозможныеРеквизитыКолонокРеестра()
	
	Реквизиты = Новый Массив;
	Реквизиты.Добавить("ДатаПлатежа");
	Реквизиты.Добавить("КомиссияБанка");
	Реквизиты.Добавить("СуммаБезКомиссии");
	Реквизиты.Добавить("СуммаПлатежа");
	
	Возврат Реквизиты;
	
КонецФункции

Функция НовыйСтруктураРеестра()
	
	Результат = Новый Структура;
	Результат.Вставить("Заголовок", Новый Массив);
	Результат.Вставить("НачалоСтрокРеестра");
	Результат.Вставить("ОкончаниеСтрокРеестра");
	Результат.Вставить("СтрокиРеестра", Новый Массив);
	Результат.Вставить("Подвал", Новый Массив);
	
	Возврат Результат;
	
КонецФункции

Функция ПризнакиШапкиРеестра()
	
	ПризнакиШапки = Новый Массив;
	ПризнакиШапки.Добавить("#");
	ПризнакиШапки.Добавить("~");
	ПризнакиШапки.Добавить("<!>");
	ПризнакиШапки.Добавить("РЕЕСТР");
	ПризнакиШапки.Добавить("ДАТА");
	ПризнакиШапки.Добавить("НОМЕР");
	
	Возврат ПризнакиШапки;
	
КонецФункции

Функция ПризнакиПодвалаРеестра()
	
	ПризнакиПодвала = Новый Массив;
	ПризнакиПодвала.Добавить("=");
	ПризнакиПодвала.Добавить("СУММА");
	
	Возврат ПризнакиПодвала;
	
КонецФункции

Функция ЭтоШапка(СтрокаТекста)
	
	Результат = Ложь;
	Для Каждого ПризнакШапки Из ПризнакиШапкиРеестра() Цикл
		Если СтрНачинаетсяС(ВРег(СтрокаТекста), ПризнакШапки) Тогда
			Результат = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ЭтоПодвал(СтрокаТекста)
	
	Результат = Ложь;
	Для Каждого ПризнакПодвала Из ПризнакиПодвалаРеестра() Цикл
		Если СтрНачинаетсяС(ВРег(СтрокаТекста), ПризнакПодвала) Тогда
			Результат = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Процедура УстановитьНачалоСтрокиРеестра(Результат, Индекс, СдвинутьНачалоРеестра)
	
	Если Результат.НачалоСтрокРеестра <> Неопределено
		И Не СдвинутьНачалоРеестра Или Результат.НачалоСтрокРеестра = 1 Тогда
		Возврат;
	КонецЕсли;
	
	Результат.НачалоСтрокРеестра = Индекс;
	
КонецПроцедуры

Процедура УстановитьОкончаниеСтрокРеестра(Результат, Индекс)
	
	Результат.ОкончаниеСтрокРеестра = Индекс;
	
КонецПроцедуры

#КонецОбласти

#КонецЕсли
